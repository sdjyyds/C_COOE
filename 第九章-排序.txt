                                                      排序
目的：方便数据的查找	排序分为内排序和外排序	常用排序方法：插入排序，快速排序，选择排序，归并排序，以及之间的比较

掌握：插入排序：直接插入排序和希尔排序
     交换排序：冒泡排序和快速排序
     选择排序：直接选择排序和堆排序
     归并排序

1.排序：将数据元素的任意序列，重新排成一个有序的序列。

2.两种基本的操作：（1）比较关键字的大小（2）根据比较结果，移动元素的位置。

3.对关键字排序的三个原则：（1）关键字为数值型的，根据键值大小进行排序。
			（2）关键字值为ASCII码，则按键值的内码编排顺序为依据。
			（3）关键字值为汉字字符串类型，则大多以汉字拼音的字典顺序进行排序。

4.待排序记录的三种方式：
（1）待排记录放在地址连续的一组存储单元上。
（2）待排记录放在静态链表中。
（3）代排记录放在一组地址连续的存储单元中，同时另设一格指示各个记录存储位置的存储的地址向量，在排序的过程中不移动继续的本身，而移动这些地址相中这些记录的“地址”，在排序结束后再按照地址向量的值调整记录的存储位置。

5.内部排序：整个过程完全在内存中进行。
6.外部排序：由于待排的数据量太大，内存无法容纳全部的数据，排序需要借助外部存储设备才能完成。
7.稳定排序和不稳定排序：当交换数据元素的时候，发生数据的跳跃交换的为不稳定排序，反之为稳定排序。

排序记录的数据类型定义如下：
	#define MAXSIZE 100
	typedef int KeyType;
	typedef struct
	{
	    KeyType key;
	}LinkList;
//为了统一算法，本章的所有排序算法中记录的数组下标值都从1到n（而不是从0到n-1）

插入排序

1.直接插入排序
（1）直接插入排序是一种最简单的排序方法，它的基本思想是将记录序列中的每一个记录插入到有序段中，使有序段的长度不断扩大。
有n待排序记录序列中的第一个记录作为有序段，此时这个有序段中只有一个记录。
（2）从第二个记录到最后一个记录，依次将记录和前面的记录进行比较，确定记录要插入的位置。
（3）将记录插入到子序列中，子序列的长度加1，直至子序列的长度和原来待排序列的长度相等，排序结束。
    则经过n-1趟就可以将初始序列的n个记录重新排成按关键字大小排列的有序序列。
  为防止在比较的过程中数组下标的溢出，我们设置一个监哨r[0]，即先将要比较的关键字存入监哨r[0]中，然后再用r[0]从后往前进行比较。若r[0]小于所比较的关键字，则将该关键字后移，腾出位置，因前方的序列都是有序的，所以可以将整体往后移，最后到r[0]大于等于所比较的关键字时结束，所以在当前记录后的位置是空出来的，直接将r[0]存入即可。
2.直接插入排序算法
    void InsertSort(LineList r[],int n)
    {
	int i,j;
	for(i=2;i<=n;i++)
	{
		r[0]=r[i];
		j=i-1;
		while(r[0].key<r[j].key)
		{
			r[j+1]=r[j];
			j--;
		}
		r[j+1]=r[0];
	}
    }
3.效率分析
  从空间的角度来看，它只需要一个辅助空间r[0]；
  从时间的角度来看，主要时间耗费在关键字比较和移动元素上；
向有序表中逐个插入记录的操作，进行了n-1趟，每趟操作分为比较关键字和移动记录，而比较的次数和移动记录的次数取决于待排关键字的初始序列；
  最好的情况下：每趟操作只需要1次比较和2次移动（仅有的两次移动式将待插入的记录移动到监哨，再从监哨移出）
	总比较次数：n-1；
	总移动次数：2(n-1)；
  最坏的情况下：如果待排序列是逆序的，将r[0]插到合适的位置，要进行i-1次关键字的比较，记录移动的次数为i-1+2。算法的比较次数和移动次数达到最大值。
	总比较次数=(n+2)(n-1)/2；
	总移动次数=(n-1)(n+4)/2；
因此，直接插入排序的时间复杂度为O(n^2),(只有一个监哨占位)空间的复杂度为O(1);并且交换元素的时候没有产生跳跃，所以这是一种稳定的排序。

希尔排序(Shell's Sort)
  希尔排序又称减少增量排序，它也是一种插入排序方法，但在时间上比直接排序方法有了很大的改进。
  
  1.希尔排序的思想
    先将待排序的记录划分为若干个子序列分别进行插入排序，当记录的排序已经基本有序，最后在对所有的记录进行一次直接插入排序。
   希尔排序的具体方法如下：
 (1)取定一个正整数d1<n,把di作为间隔值，把全部数据从第一个记录开始进行分组，把所有距离为di的倍数的记录放在一组中，在各组中分别进行直接插入排序。 
 (2)取定一个正整数d2<d1,重复上述分组和排序的操作，知道di为1为止，及所有记录在同一个序列进行直接插入排序。
  希尔提出d1=[n/2],]di+1=[di/2];
  
 2.希尔排序的算法
  void ShellSort(LineList r[],int n)
{
    int i,j,d;
    d=n/2;
    while(d>0)
    {
	for(i=d;i<=n;i++)
	{
	    r[0]=r[i];
	    j=i-d;
	    while(j>=0&&r[0].key<r[j].key)
	    {
		r[j+d]=r[j];
		j=j-d;
	    }
	    r[j+d]=r[0];
	}
	d=d/2;
    }
}
3.算法效率分析
  希尔排序分析是一个复杂的问题，有人在大量的实验推出：当n在某个特定的范围内希尔排序所需要比较和移动的次数为O(n^1.3)。

  交换排序
  
  交换排序的基本方法是：通过两两比较待排序的关键字，若有不满足次序要求的一对数据则交换，直到全部满足为止。

  冒泡排序：
1.基本思想： 
  它的基本思想是对所有相邻的关键字进行比较，若逆序则将其交换，从而使得关键字值小的纪录向上飘（左移），关键字大时将其下沉
每经过一趟冒泡排序，都使得无序区关键字最大的纪录进入有序区，对于由n个记录组成的记录序列，最多经过n-1趟冒泡排序，就可以将这n个记录重新按关键字顺序排列。

2.冒泡排序算法
  对与由n个记录组成的记录序列，最多经过n-1趟冒泡排序，就可以使得记录序列成为有序序列，第一趟冒泡排序定位到第n位，第二趟冒泡排序定位到第n-1位。

冒泡排序算法：
    void Bubble_sort(int r[],int n)
  {
    int i,j,exchange;
    for(i=1;i<n;i++)
    {
	exchange=0;
	for(j=1;j<=n-i;j++)
	if(r[j].key<r[j+1].key)
	{
	    exchange=1;
	    a[0]=a[j];
	    a[j]=a[i];
	    a[i]=a[0];
	}
	if(exchange) break;
    }
  }

3.效率分析
(1)空间效率：仅用了一个辅助单元，空间复杂度为O(1)；
(2)时间效率：总共要进行n-1趟冒泡，对j个记录的表进行一趟冒泡需要j-1次关键字的比较。
	总比较次数：n(n-1)/2；
    最好的情况，有序，无需移动
    最坏的情况：每次比较之后都需要三次移动
	总移动次数：3*n(n-1)/2;
所以冒泡排序的时间复杂度为：O(n^2)；
	
快速排序
  是对起泡排序的一种改进。
  1.快速排序的基本思想
  又称分区交换排序，通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字都比另一部分的关键字小，则可以分别对这两部分记录进行排序，以达到整个序列有序。
  具体过程是：首先将待排序的序列中所有的记录作为待排序的区域，从中任选(通常为第一个)取一个记录作为支点，并以该记录的关键字为基准，从未与待排序两端开始，逐渐向中间靠拢，交替与基准记录的关键字进行比较，交换
  每次比较若遇到左侧记录关键字值大于基准关键字值，则于基准记录交换，使其移动到基准记录的右侧，若遇到右侧关键字值小于基准关键字值，则将基准关键字与左侧关键字交换。
  快速排序算法
    void quick_sort(int r[],int first,int end)
  {
     int i=first,j=end;
     LineList temp=r[i];
     while(i<j)
     {
         while(i<j&&r[j].key>=temp.key)j--;
	 r[i]=r[j];
	 while(i<j&&r[i].key<=temp.key)i++;
         r[j]=r[i]; 
     }
     r[i]=temp;
     if(i-first>1) quick_sort(r,first,i-1);
     if(end-i>1)   quick_sort(r,i+1,end);
  }
  
  3.效率分析：
    空间效率：快速排序是递归的，每层递归调用时的指针和参数均要用栈来存放，递归调用的层次数与上述二叉树的深度一致，则时间的复杂度为O(n*log2n),即树的高度，最坏的情况是一个单链表，为O(n)；
    时间效率：在n个记录待排序的序列中，一次划分需要为n次的关键码比较，时效为O(n)，
    理想情况下：每次划分，正好将分成两个等长的子序列，则时间的复杂度为O(nlog2n)；
    最坏的情况下：快速排序每次划分之得到一个子序列，这是快速排序蜕变为冒泡排序，时间复杂度为O(n^2)；
    快速排序通常是被认为在同量级O(nlog2n)的排序方法中平均性能是最好的。快速排序是一个不稳定的排序。
  
  选择排序
    选择排序的过程中是指在排序的过程中，依次从待排序中选择关键字值最小或最大的记录，并分别将他们定位到序列的左侧第一个位置，第二个位置，最后剩下一个关键字值最大或最小的记录位于序列的最后一个位置，从而使待排序列的记录序列成为按关键字值由大到小排列的有序序列。
  
直接选择排序
    1.直接排序的基本思想是在每一趟n-i+1个记录中选取关键字值最大或最小的记录作为有序序列的第i个记录。
     
    它的具体实现过程如下
    (1)将整个序列划分为两个部分：有序区域位于最左端，无序区域位于最右端。
    (2)基本操作：从无序区域选择关键字值最小的记录，将其与无序区的第一个记录交换位置(实际上是放到有序元素的底部)
  (3)重复1，2就完成了。
    void select_sort(int r[],int n)
  {
         int i,j,k;
     lineList temp;
     for(i=1;i<n;i++)
     {
	k=i;
	for(j=i+1;j<=n;j++)
	{
	    if(r[j].key<r[k].key)
	    {
		k=j;
	    }
	}
	if(k!=i)
	{
	 //交换
	   temp=r[i];
	  r[i]=r[k];
	  r[k]=r[i];
	}
    }
  }
  
  3.效率分析
  直接选择排序与关键字初始排序无关。
    着地一个最小记录需要进行n-1次比较，找到第二个分量最小记录需要比较n-2次，以此类推
	总比较次数为：(n-1)+(n-2)+(n-3)+……+2+1=n*(n-1)/2=n^2/2;
  直接选择排序的时间复杂度为O(n^2),空间复杂度为O(1),此算法是不稳定排序。

  堆的排序(Heap Sort)
 1.堆的定义：堆的排序是利用堆树(Heap Tree)来进行排序的方法，堆树是一种特殊的二叉树，其具备以下的特征：
  
 2.堆序列的基本思想
 (1)把用数组来存储待排序的数据，转换成一颗完全的二叉树。
  (2)将完全二叉树转换成堆树。
 (3)有了堆树后，我们就开始排序
  因此，堆排序的关键步骤有两个
  (1)构造堆，即如何将一个无序序列建成初始堆；
 (2)调整堆，即如何在输出堆的根节点之后，调整剩余元素成为一个新的堆；
  首先考虑(2)调整堆；然后再考虑(1)构造堆；
  
  3.实现堆排序
  (1)调整堆。假设有一个小根堆
 4.堆排序算法
void sift(LineList r[],int low,int high)
{
	int i=low,j=2*low;
	LineList temp=r[i];
	while(j<=high)
	{
		if(j<high&&r[j].key<r[j+1].key) j++;
		if(temp.key<r[j].key) r[i]=r[j],i=j,j=2*i;
		else break;
	}
	r[i]=temp;
}
void HeapSort(LineList r[],int n)
{
	int i,j;
	LineList temp;
	for(i=n/2;i>=1;i--) sift(r,i,n);
	for(j=n;j>=1;j--)
	{
		temp=r[1];
		r[1]=r[j];
		r[j]=temp;
		sift(r,1,j-1);
	}
	for(i=1;i<=n;i++) printf("%d ",r[i].key);
}